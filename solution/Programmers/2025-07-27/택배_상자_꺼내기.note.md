# 알고리즘 문제 해결

link: https://school.programmers.co.kr/learn/courses/30/lessons/389478

## 문제 이해

- **핵심 요구사항**
  - 1~n번 택배 상자를 가로 w개씩 층층이 쌓음
  - 짝수 층(0, 2, 4...): 왼쪽→오른쪽 순서로 배치
  - 홀수 층(1, 3, 5...): 오른쪽→왼쪽 순서로 배치
  - 특정 번호(num) 상자를 꺼내려면 그 위의 모든 상자를 먼저 제거해야 함
  - 목표: num번 상자를 포함해 총 몇 개의 상자를 꺼내야 하는지 계산

- **제약조건**
  - 상자는 수직으로만 쌓임 (같은 열의 상자들만 영향을 받음)
  - 상자 번호는 1부터 시작
  - 층별로 교대로 배치 방향이 바뀜

## 접근 방법

- **핵심 아이디어**
  1. 목표 상자(num)가 어느 층, 어느 열에 위치하는지 계산
  2. 각 층의 배치 방향(좌→우 또는 우→좌)에 따라 열 위치 결정
  3. 목표 상자 위의 모든 층을 순회하며 같은 열에 있는 상자들 카운트
  4. 목표 상자 자체도 포함하여 총 개수 반환

- **시간/공간 복잡도**
  - 시간복잡도: O(층의 개수) = O(n/w) - 각 층을 한 번씩만 확인
  - 공간복잡도: O(1) - 추가 배열이나 자료구조 불필요

## 코드

```typescript
export const solution = (n: number, w: number, num: number) => {
  // 목표 상자가 위치한 층과 층 내 위치 계산
  const targetLayer = Math.floor((num - 1) / w);
  const positionInLayer = (num - 1) % w;

  // 층의 배치 방향에 따른 열 위치 계산
  let targetColumn: number;
  if (targetLayer % 2 === 0) {
    // 짝수 층: 왼쪽→오른쪽
    targetColumn = positionInLayer;
  } else {
    // 홀수 층: 오른쪽→왼쪽  
    targetColumn = w - 1 - positionInLayer;
  }

  let boxesToRemove = 1; // 목표 상자 포함

  // 목표 층 위의 모든 층 확인
  const totalLayers = Math.ceil(n / w);

  for (let layer = targetLayer + 1; layer < totalLayers; layer++) {
    const layerStartBox = layer * w + 1;
    const layerEndBox = Math.min((layer + 1) * w, n);

    // 현재 층에서 목표 열에 위치한 상자 번호 계산
    let boxAtColumn: number;

    if (layer % 2 === 0) {
      // 짝수 층: 왼쪽→오른쪽
      boxAtColumn = layerStartBox + targetColumn;
    } else {
      // 홀수 층: 오른쪽→왼쪽
      boxAtColumn = layerStartBox + (w - 1 - targetColumn);
    }

    // 해당 상자가 실제로 존재하는지 확인 후 카운트
    if (boxAtColumn >= layerStartBox && boxAtColumn <= layerEndBox) {
      boxesToRemove++;
    }
  }

  return boxesToRemove;
};
```

## 회고

- **배운 점**
  - 2차원 배치 문제에서 교대로 방향이 바뀌는 패턴을 수식으로 처리하는 방법
  - 층별 인덱싱과 전체 인덱싱 간의 변환 공식: `층 = Math.floor((번호-1) / 폭)`, `위치 = (번호-1) % 폭`
  - 홀수/짝수 층 구분을 통한 좌우 반전 로직: `반전위치 = 폭 - 1 - 원래위치`
  
- **다음에 비슷한 문제를 만났을 때**
  - 먼저 배치 패턴을 정확히 파악하고 규칙을 찾기
  - 좌표 변환 공식을 명확히 정의한 후 구현
  - 경계 조건(마지막 층이 불완전한 경우 등)을 꼼꼼히 체크
  - 테스트 케이스로 작은 예시부터 단계별 검증
  - 코드 복습 필요함 